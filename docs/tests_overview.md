# Test Suites – Circuits & Proof System

The *major* automated tests that exercise the arithmetic circuits, prover and verifier code.  It is **not** an exhaustive list of every `#[test]` function.  We focus on tests that validate correctness of the constraint systems, witness generation, proof production, and on-chain verifier skeletons.

> To run any of the tests below use Cargo’s standard interface, e.g.:
> ```bash
> cargo test -p opcode_tests jalr::test_jalr_op   # Example of single opcode test
> ```

---

## 1. Opcode-level functional tests (`opcode_tests` crate)

**Location**: `circuit_defs/opcode_tests/`

Purpose: Ensure that the full-machine circuit correct compile every RISC-V instruction.

How it works:
1. Runs the reference RISC-V simulator for a *single instruction*  with randomised register/memory state.
2. Generates a witness for the *same* step using the circuit.
3. Compares resulting register values, memory reads/writes, PC updates, etc.

Highlights:
- 40+ individual tests (`src/opcodes/*.rs`) – one per opcode (`add.rs`, `lb.rs`, `jal.rs`, …) each containing a `test_<opcode>` function.
- Additional tests in `src/lib.rs` (`test_single_opcode`, `broken_tests`, etc.) gather multiple opcodes.
- Can be run with: `cargo test -p opcode_tests --profile test-release`.
These tests provide **completeness coverage** – if an opcode is incorrectly constrained, the comparison with the simulator will fail.

---

## 3. Program-level prover & delegation tests (`prover` crate)

**Location**: `prover/src/tests/`

Purpose: Exercise the *entire* STARK proving pipeline, through witness generation, to proof creation and verification on small RISC-V programs and cryptographic delegation gadgets.

How it works:
1. Embeds a short RISC-V binary or loads a `.bin` file.
2. Calls `run_test_for_binary(...)` which  
   - executes the program in the reference simulator,  
   - synthesises the corresponding witness,  
   - generates a proof, and  
   - immediately verifies it.
3. For delegation circuits a specialised helper `run_basic_delegation_test_impl(...)` performs the same end-to-end cycle.

Representative tests:
- **`test_blake2_single_round`** – validates the Blake2 compression round delegation against known test-vectors.
- **`test_extended_blake2_single_round`** – covers the extended Blake2 state transformation.
- **`test_bigint_with_control_call`** – 256-bit arithmetic with the additional control selectors.
- **`multiple_instances_test`** – runs batches of tiny programs (Fibonacci, arithmetic, jumps) to check that batched proof generation / verification works.
- **`gpu_prover::basic_test`** – produces the same proof on CPU *and* GPU.

Run with:
```bash
cargo test -p prover                
cargo test -p prover test_blake2_single_round
```

Why it matters: Sits one level *above* opcode-unit tests and therefore catches integration issues across the simulator, constraint system, commitment scheme, and recursion layers.

---

## 4. Verifier-side skeleton tests (`verifier` and friends)

Crates:
* `verifier`
* `circuit_defs/*/verifier` (one per machine configuration & delegation gadget)

Key files: `verifier/src/tests.rs`, plus duplicated copies generated for each machine config.

There are usually two flavours:
- **`test_full_machine_verifier_out_of_simulator`** / `test_reduced_machine_verifier_out_of_simulator` – run the verifier directly in a Rust thread.
- **`test_verifier_in_simulator`** – cross-compile the verifier skeleton into a RISC-V ELF, then run it *inside* the cycle-accurate simulator.

Running example:
```bash
cargo test -p verifier test_full_machine_verifier_out_of_simulator -- --nocapture
```

These tests are heavier – they perform full Merkle verifications and FRI checks – but are essential to guarantee that proofs generated by the prover will be accepted on-chain.

---

## 5. FFT & Field arithmetic correctness 
Examples:
| Crate | File | Notes |
|-------|------|-------|
| `fft` | `src/row_major/tests.rs` & several functions marked `#[test]` in `src/grinded_fft/*` | Validate NTT/FFT forward & inverse consistency, coset conversions, butterfly kernels, etc. |
| `field` | (many small `#[test]` items inline) | Check field arithmetic, inversion, serialization, randomness, etc. |

Run with:
```bash
cargo test -p fft   
```

---

## 6. Prover integration ests (`prover_examples`)

Crate **`circuit_defs/prover_examples`** contains:
2. Runs the full staged prover pipeline.
3. Optionally serialises the resulting proof for later use by verifier tests.

Because it exercises *all* prover stages together, it’s almost end-to-end check.  It is *slow*.

---

TODO